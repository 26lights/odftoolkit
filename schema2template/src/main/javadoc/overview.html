<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--
Reference this overview.html
by specifying it in an ant task, like:
<javadoc
  ...
  overview="${path-to-overview.html}/overview.html"
/>
-->
<html>
<body> 
The schema2template project's objective is to provide an API for easily filling user templates from arbitrary XML schematas. Common use cases for generation are
<br><p><ul type="disc">
		<li>Source code of DOM classes based on the schema (i.e. elements as classes with attributes as their attributes)</li>
		<li>XML reference as linked HTML file</li>
</ul></p>   

<p>
            
<h2>Introduction</h2>

<p>This project allows you to process a RelaxNG schema file and to convert the definitions to any text based format you like. E.g.
you can produce one source code file for each element defined in schema file. Or maybe you want to produce one single text or HTML
based overview of the schema.</p>

<p>Since this project is based on the Sun Multi Schema Validator, it should be able to process multiple schema formats. However up to now it has only been
tested with RelaxNG.</p>

<p>Several examples are delivered together with this project:
<ol>
<li>Read the OpenDocument Schema and produce a Java based DOM API</li>
<li>Read the OpenDocument Schema and produce an HTML overview of all ODF elements and attributes</li>
<li>Read the OpenDocument Schema and produce one single Python file which represents the element hierarchy</li>
</ol>
</p>

<p>A non-trivial topic is the concept of multiple definitions for a single element or attribute, which is possible in RelaxNG. 
The easiest way would be to unite these definitions (we call them Multiples) to one common definition. However this way important information would be lost.
E.g. one element may have the attribute foo whith possible value <em>left</em>. This attribute may also be possible in another element, but then with 
possible values <em>left</em> and <em>right</em>. That's why we decided to keep the distinction, even if it may make it harder to understand the API of this project. 
We might enhance this concept in the future, e.g. to exactly determine which of the multiple Definitions holds for the current element in an ODF element tree.
</p>

<h2>Velocity Help</h2>

Go to the "Engine" section of the the Velocity <a href="http://velocity.apache.org/">project site</a> to find the Velocity User Guide.

The velocity template structure and commands are explained there.

<h2>Schema2Template file structure</h2>

<p>We use a 2-step procedure: First we generate a list of files we'd like to create. While we could write this list manually, the generation of this
list frees us from having to write an entry for each schema element or attribute.

The template to generate this list is called filelist.vm, the list itself (i.e. the result of running filelist.vm) is called filelist.xml.</p>

<p>Here's an example filelist.xml:</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;filelist&gt;
    &lt;file path=&quot;OdfHtmlSpecification.html&quot; template=&quot;odf-reference-template.vm&quot; /&gt;
    &lt;file path=&quot;element/anim/AnimAnimateElement.java&quot; 
    	     context=&quot;anim:animate&quot; 
	     template=&quot;java-odfdom-element-template.vm&quot; /&gt;
    ...
&lt;/filelist&gt;
</pre>

<p>In the second step we parse filelist.xml. For every "file" entry we run the given Velocity "template", fill its context with the optional "context"  
property and write the output to the given "path". 
The "context" property (and as seen later - the optional "param" property as well) is used in templates which process only one element or attribute - 
to provide them with the name of this element or attribute. 
In the above example the template for the generation of a Java class is such a template, while the template to produce the whole 
OdfHtmlSpecification.html is a template whith a global context, i.e. it processes the whole Schema.</p>

<h2>Schema2Template specific template help</h2>

<p>In velocity templates, you have context objects, provided by the Java Velocity Runner Class. These are Java objects and you can call any method 
of these objects like you would do in Java. In Schema2Template we provide the following context objects (see JavaDoc of the given Classes):</p>

<ul>
<li>SchemaModel model: Provides the elements and attributes defined in the schema.</li>
<li>OdfModel odfmodel: Provides additional information from the Odf Specification, like attribute standard values or element style families.</li>
<li>JavaModel javamodel: Provides additional information for generation of Java Code, like common base classes for elements.</li>
<li>String context: The (optional) name of the current element. You can use model to get the element or attribute described by this name</li>
<li>String param: A freely usable (optional) argument. An example usage is to provide a number to distinguish between elements (or attributes) sharing the same name.</li>
</ul>

<p>It should be noted that the context of filelist.vm behaves like the context of all templates which are started from there. Of course in the 
context of filelist.vm the optional context Objects "context" and "param" are null.</p>

<h3>Definition Class</h3>

<p>The Definition class provides some sort of "piece of a puzzle", containing the definition of an Odf element, attribute, datatype or
constant attribute value. This class contains methods for quiering the relationship between Definitions, e.g. to get all child elements,
attributes, parent elements, datatypes, values, etc... Definitions are
sorted by their name (which has the form "ns:localname").</p>

<p>Some of these return parameters are collections. For these there is the class DefinitionSet, which is a SortedSet of Definitions. Definition
and DefinitionSet both implement the interface NamedDefined, and therefore have many methods in common (you can query all child elements
for a Definition as well as for a whole DefinitionSet. And you can get the name for a Definition as well as for a whole DefinitionSet - provided all Definitions 
are equally named, ...)</p>

<p>Before we come to the point on how to use Definitions and how to get them, there's one more important thing to know: </p>

<h3>Multiples and Multiple Number</h3>

<p>One element (form:list-value) and many attributes (chart-symbol-type, text:outline-level, etc...) are defined multiple times in Odf Schema. 
Each definition is represented by a Definition object. Those Definition objects sharing the same name are called Multiples.
Each Multiple may differ in parent elements, child elements and attributes.
From a Definition you can get all Definitions sharing the same name as the Definition 
by its method withMultiples(). If there are no other Definitions you get at least a singleton DefinitionSet containing only this Definition.</p>

<h3>How to get NamedDefined (Definitions and DefinitionSets)</h3>

<p>If you do not want to distinguish between elements (or attributes) sharing the same name you can use in templates processing only one element:<br />
$model.getElement($context) or $model.getAttribute($context). By this you get a DefinitionSet of Definitions sharing the same name. Since both
classes share most methods, you can go on with your template like you'd use one single Definition.</p>

<p>If you want to distinguish between elements (or attributes) sharing the same name you can use in templates processing only one element:<br />
$model.getElement($context, $param) or $model.getAttribute($context, $param), provided that context contains the name of the Definition and param 
contains the multiple number to distinguish between these Definitions. In other words you have to fill both properties in filelist.vm with the needed values.
You get the name of a Definition by ${aDefinition.getQName()} or directly by $aDefinition and the multiple number by ${aDefinition.getMultipleNumber()}.<br />
<em>It should be noted that this is a very rare use case (e.g. if you want to produce one file per Definition and not - as usual - per Definition name).</em>
</p> 

<p>If you loop over a Set of Definitions, this Set will contain Multiples. If you want to distinguish between these elements/attributes, there's nothing special to do.
But if you do not want to distinguish between elements/attributes sharing the same name, you have two steps to do: <br />
First, you have to create a new DefinitionSet without
these Multiples by myDefinitionSet.withoutMultiples(). Now you still have a Set of Definitions, but only one (random) Definition per name remains. <br />
If you'd process only the random remaining Definition for a name, and you're processing more than just the Definition name, you might miss some information 
contained in the removed multiples. Even more, since you distinguish only between names, there might be some information contained in 
Multiples which weren't even in the list before. (like an attribute Multiple
which wasn't in the $element.getAttributes() list as it's only defined for another element). So to get all
Multiples (not only those which were contained in the Set) of a Definition, you use aDefinition.withMultiples().</p>

<h3>How to use NamedDefined (Definitions and DefinitionSets)</h3>

<p>Mostly you might want to use a Definition by inserting it directly into the template, like "this element is called $element", or
like "the namespace of this element is ${element.getNamespace()}". It doesn't matter if $element is a Definition as returned by model.getElement($context, $param),
or a DefinitionSet of equally named Definitions as returned by model.getElement($context).</p>

<p>The model provides a few additional functions for String formatting like model.camelCase($element) for text:p -&gt; TextP or model.javaCase($element) 
for text:p -&gt; textP.</p>

<p>Another usage of NamedDefineds is to get other NamedDefineds, e.g. by $element.getParents(), $attribute.getDatatypes(), $attribute.getValues(), 
$element.getChildElements(), $element.getAttributes().</p>

<p>To restrict a DefinitionSet only to the Definitions which have a common parent, there is $elements.byParent($equallyNamedParents). With this method
you can implement very distinct validation method in attribute classes (implementation detail for the following example: one attribute and one parent class implemented per name - 
thus ignoring Definition multiples at Java class level. However differences between attribute Definitions are respected by using a different validation): 
<pre>
  ## This will return a DefinitionSet containing all attribute Definitions with name $context
  #set($attribute = ${model.getAttribute($context)})
  ...
  public void setValue(String value) {
  	boolean valid = false;
  ##
  ## Iterate over parent names and get all Multiples for each name
  #foreach ($singleparent in ${attribute.getParents().withoutMultiples()})
  #set ($parent = $singleparent.withMultiples())
  	if (getParent() instanceof ${model.camelCase($parent)}Element) {
  ##
  ## Allow only datatypes from attribute definitions reachable from $parent
  ## Thus here we're respecting the different definitions for the current attribute
  #foreach ($datatype in ${attribute.byParent($parent).getDatatypes()})
    		valid = valid || validate(${datatype}.class, value);
  #end
	}
  #end
  	if (!valid) {
		throw new IllegalArgumentException(
			"Invalid Value for attribute $attribute and parent " 
			+ getParent().ELEMENT_NAME);
	}
	mValue = value;
  }
</pre>
</p>

<h3>Examples</h3>

<h4>Here's an example template to generate a ODF reference of attribute / elements. Here the Definitions are distinguished:</h4> 
<pre>
#foreach( $element in ${model.getElements()} )
#if (${element.withMultiples().size()} == 1)
#set ($duptext = "")
#set ($hasdup = false)
#else
#set ($duptext = "[${element.getMultipleNumber()}]")
#set ($hasdup = true)
#end
&lt;h3&gt;${element}${duptext} Element&lt;/h3&gt;
#if ( $hasdup )
&lt;p&gt;There are more than one Definitions by this name.&lt;/p&gt;
#end
#end
</pre>

<h4>Here's an example filelist.vm which only produces one entry per name (processing just the element name so the Multiples can safely be removed):</h4>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;filelist&gt;
    &lt;file path=&quot;OdfHtmlSpecification.html&quot; template=&quot;odf-reference-template.vm&quot; /&gt;
##
#foreach ( $element in ${model.getElements().withoutMultiples()} )
##
#set($classname = &quot;${model.camelCase($element)}Element&quot; )
    &lt;file path=&quot;element/${element.getNamespace()}/${classname}.java&quot; 
             context=&quot;$element&quot; 
	     template=&quot;java-odfdom-element-template.vm&quot; /&gt;
##
#end
&lt;/filelist&gt;
</pre>

<h4>Here's an example template to generate a Java class for an element name (by looking at all element Multiples at once).</h4> 

<p>To keep it short only the part where the Getter-Methods for all attribute names (by looking at all attribute multiples at once) are generated is shown:</p>
<pre>
## This will return a DefinitionSet containing all element Definitions with name $context
#set($element = ${model.getElement($context)})
...
##
## Step 1: Iterate over all attributes with one random attribute Definition per attribute name 
#foreach ( $singleattr in ${element.getAttributes().withoutMultiples()} )
##
## Step 2: Get all attribute definitions for one attribute name. 
## Not needed if we're just processing the attribute name
#set($attribute = ${singleattr.withMultiples()}
##
#set($aClassname = &quot;${model.camelCase($attribute)}Attribute&quot; )
	/**
	 * Gets the value of the &lt;code&gt;$aClassname&lt;/code&gt; attribute, 
	 * see {@odf.attribute ${attribute}}
	 *
	 * @return - the &lt;code&gt;String&lt;/code&gt; attribute value
	 */
	public String get${aClassname}() {
	   ...
	}
#end
...
</pre>
</body>
</html>
